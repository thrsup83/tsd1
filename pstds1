
$TargetUserName = "" 
$LogDir = "z:\scripts\logs1"
$LogFile = "$LogDir\Monitor_LogonRights.txt"
$CheckIntervalSeconds = 15

if (!(Test-Path $LogDir)) { New-Item -ItemType Directory -Path $LogDir -Force | Out-Null }

$LsaCode = @"
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace LsaSecurity {
    public class Wrapper {
        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern uint LsaOpenPolicy(ref LSA_UNICODE_STRING SystemName, ref LSA_OBJECT_ATTRIBUTES ObjectAttributes, uint DesiredAccess, out IntPtr PolicyHandle);
        
        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern uint LsaEnumerateAccountRights(IntPtr PolicyHandle, byte[] AccountSid, out IntPtr UserRights, out ulong CountOfRights);
        
        [DllImport("advapi32.dll")] private static extern uint LsaClose(IntPtr ObjectHandle);
        [DllImport("advapi32.dll")] private static extern uint LsaFreeMemory(IntPtr Buffer);

        [StructLayout(LayoutKind.Sequential)] private struct LSA_UNICODE_STRING { public ushort Length; public ushort MaximumLength; public IntPtr Buffer; }
        [StructLayout(LayoutKind.Sequential)] private struct LSA_OBJECT_ATTRIBUTES { public int Length; public IntPtr RootDirectory; public IntPtr ObjectName; public uint Attributes; public IntPtr SecurityDescriptor; public IntPtr SecurityQualityOfService; }

        public static List<string> GetAccountRights(string sidString) {
            uint POLICY_LOOKUP_NAMES = 0x00000800; 
            IntPtr policyHandle = IntPtr.Zero;
            LSA_OBJECT_ATTRIBUTES objAttr = new LSA_OBJECT_ATTRIBUTES();
            LSA_UNICODE_STRING sysName = new LSA_UNICODE_STRING();
            List<string> rightsList = new List<string>();

            uint res = LsaOpenPolicy(ref sysName, ref objAttr, POLICY_LOOKUP_NAMES, out policyHandle);
            if (res != 0) return rightsList; // Failed to open policy

            try {
                SecurityIdentifier sid = new SecurityIdentifier(sidString);
                byte[] sidBytes = new byte[sid.BinaryLength];
                sid.GetBinaryForm(sidBytes, 0);

                IntPtr userRightsPtr = IntPtr.Zero;
                ulong countOfRights = 0;

                res = LsaEnumerateAccountRights(policyHandle, sidBytes, out userRightsPtr, out countOfRights);
                
                // 0xC0000034 = STATUS_OBJECT_NAME_NOT_FOUND (User has no rights assigned)
                if (res == 0xC0000034) return rightsList; 
                if (res != 0) return rightsList;

                IntPtr currentPtr = userRightsPtr;
                for (ulong i = 0; i < countOfRights; i++) {
                    LSA_UNICODE_STRING lus = (LSA_UNICODE_STRING)Marshal.PtrToStructure(currentPtr, typeof(LSA_UNICODE_STRING));
                    string rightName = Marshal.PtrToStringUni(lus.Buffer, lus.Length / 2);
                    rightsList.Add(rightName);
                    currentPtr = (IntPtr)((long)currentPtr + Marshal.SizeOf(typeof(LSA_UNICODE_STRING)));
                }
                
                LsaFreeMemory(userRightsPtr);
            }
            catch {
                // Return empty list on error
            }
            finally { 
                LsaClose(policyHandle); 
            }
            return rightsList;
        }
    }
}
"@

if (-not ("LsaSecurity.Wrapper" -as [type])) { Add-Type -TypeDefinition $LsaCode }

Write-Host "Monitoring started for: $TargetUserName" -ForegroundColor Cyan
Write-Host "Checking LSA directly every $CheckIntervalSeconds seconds..." -ForegroundColor Gray
Write-Host "Log will be saved to: $LogFile" -ForegroundColor Gray

$StartMsg = "--- MONITOR STARTED AT $(Get-Date) ---"
$StartMsg | Out-File -FilePath $LogFile -Append -Encoding UTF8

while ($true) {
    
    $BatchFound = $false
    $ServiceFound = $false
    $CurrentRights = @()
    $SidString = ""

    try {
        $objUser = New-Object System.Security.Principal.NTAccount($TargetUserName)
        $SidString = $objUser.Translate([System.Security.Principal.SecurityIdentifier]).Value
        
        # Call C# Code to get rights from LSA
        $CurrentRights = [LsaSecurity.Wrapper]::GetAccountRights($SidString)

        if ($CurrentRights -contains "SeBatchLogonRight") { $BatchFound = $true }
        if ($CurrentRights -contains "SeServiceLogonRight") { $ServiceFound = $true }
    }
    catch {
        Write-Host "Error resolving user SID. Check username." -ForegroundColor Yellow
    }

    if (-not $BatchFound -or -not $ServiceFound) {
        
        $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        
        $ErrorMsg = "[$Timestamp] CRITICAL ALERT: Account Rights REMOVED!"
        if (-not $BatchFound) { $ErrorMsg += " [Missing: SeBatchLogonRight]" }
        if (-not $ServiceFound) { $ErrorMsg += " [Missing: SeServiceLogonRight]" }

        Write-Host $ErrorMsg -ForegroundColor Red
        
        "==================================================" | Out-File -FilePath $LogFile -Append
        $ErrorMsg | Out-File -FilePath $LogFile -Append
        "Account SID: $SidString" | Out-File -FilePath $LogFile -Append
        "Current Rights Found: $($CurrentRights -join ', ')" | Out-File -FilePath $LogFile -Append
        
        "--- EVENTS FROM LAST 2 MINUTES (Event Viewer) ---" | Out-File -FilePath $LogFile -Append
        
        try {
            $Events = Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime=(Get-Date).AddMinutes(-2)} -ErrorAction Stop
            
            foreach ($Event in $Events) {
                $ProcessName = $Event.Properties[6].Value
                $SubjectUser = $Event.Properties[1].Value
                $LogLine = "TIME: $($Event.TimeCreated) | ID: $($Event.Id) | USER: $SubjectUser | PROCESS: $ProcessName"
                $LogLine | Out-File -FilePath $LogFile -Append
            }
        }
        catch {
            "No Security events found in the last 2 minutes." | Out-File -FilePath $LogFile -Append
        }
        "==================================================" | Out-File -FilePath $LogFile -Append

    } else {
        Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Account OK." -ForegroundColor Green
    }
    
    Start-Sleep -Seconds $CheckIntervalSeconds
}

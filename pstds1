$OutDir = "C:\temp\25-12-12"
New-Item -ItemType Directory -Force -Path $OutDir | Out-Null

$Account = Read-Host "Account to check (optional) e.g. DOMAIN\svc_account (Enter to skip)"
$ts = Get-Date -Format "yyyyMMdd_HHmmss"
$cn = $env:COMPUTERNAME

$summary = Join-Path $OutDir "SUMMARY_${cn}_$ts.txt"
$cfgPath = Join-Path $OutDir "UserRights_${cn}_$ts.cfg"
$secCsv  = Join-Path $OutDir "Security_${cn}_$ts.csv"
$taskCsv = Join-Path $OutDir "TaskScheduler_${cn}_$ts.csv"
$sysCsv  = Join-Path $OutDir "System_${cn}_$ts.csv"

function W([string]$s="") { Add-Content -Path $summary -Value $s }

W "=== Batch Logon Right Troubleshooting Summary ==="
W "Computer: $cn"
W "When: $(Get-Date)"
W "User: $env:USERDOMAIN\$env:USERNAME"
W ""

$boot = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
W "LastBootUpTime: $boot"

$dbPath  = Join-Path $env:windir "security\Database\secedit.sdb"
$logPath = Join-Path $env:windir "security\logs\scesrv.log"
$db = Get-Item $dbPath -ErrorAction SilentlyContinue
$sl = Get-Item $logPath -ErrorAction SilentlyContinue

W ""
W "File stamps:"
if ($db) { W (" - secedit.sdb: {0} | LastWriteTime={1} | Length={2}" -f $db.FullName,$db.LastWriteTime,$db.Length) } else { W " - secedit.sdb: NOT FOUND" }
if ($sl) { W (" - scesrv.log:  {0} | LastWriteTime={1} | Length={2}" -f $sl.FullName,$sl.LastWriteTime,$sl.Length) } else { W " - scesrv.log:  NOT FOUND" }

W ""
W "Exporting USER_RIGHTS to: $cfgPath"
try {
  secedit /export /cfg "$cfgPath" /areas USER_RIGHTS /quiet | Out-Null
  W "Export OK."
} catch {
  W "Export FAILED: $($_.Exception.Message)"
}

$batchLine = $null
$servLine  = $null

if (Test-Path $cfgPath) {
  $lines = Get-Content $cfgPath -ErrorAction SilentlyContinue
  $batchLine = $lines | Where-Object { $_ -match '^SeBatchLogonRight\s*=' } | Select-Object -First 1
  $servLine  = $lines | Where-Object { $_ -match '^SeServiceLogonRight\s*=' } | Select-Object -First 1

  W ""
  W "Current rights (raw):"
  if ($batchLine) { W (" - " + $batchLine) } else { W " - SeBatchLogonRight = <not present in export>" }
  if ($servLine)  { W (" - " + $servLine)  } else { W " - SeServiceLogonRight = <not present in export>" }
} else {
  W ""
  W "User rights export file not found, skipping rights parsing."
}

$acctSid = $null
$present = $null
if ($Account -and $batchLine) {
  try {
    $acctSid = (New-Object System.Security.Principal.NTAccount($Account)).Translate([System.Security.Principal.SecurityIdentifier]).Value
    $present = ($batchLine -match [regex]::Escape("*$acctSid"))
  } catch {
    $acctSid = "<cannot translate to SID>"
    $present = $null
  }

  W ""
  W "Account check:"
  W " - Account: $Account"
  W " - SID: $acctSid"
  if ($present -ne $null) { W " - Present in SeBatchLogonRight? $present" } else { W " - Present in SeBatchLogonRight? <unknown>" }
}

W ""
W "AuditPol (read-only):"
try {
  $ap = & auditpol /get /subcategory:"Authorization Policy Change" /r 2>$null
  W ($ap -join "`n")
} catch {
  W "auditpol read failed."
}

if ($db) {
  $t = $db.LastWriteTime
  $start = $t.AddMinutes(-30)
  $end   = $t.AddMinutes(30)

  W ""
  W "Event correlation window (based on secedit.sdb LastWriteTime):"
  W " - Start: $start"
  W " - End:   $end"

  $secOut = @()
  try {
    $rawSec = Get-WinEvent -FilterHashtable @{LogName='Security'; StartTime=$start; EndTime=$end; Id=4704,4705,4688} -ErrorAction Stop |
              Sort-Object TimeCreated
    foreach ($ev in $rawSec) {
      $x = [xml]$ev.ToXml()
      $d = @{}
      foreach($n in $x.Event.EventData.Data){ $d[$n.Name] = $n.'#text' }

      $subject = if($d.SubjectUserName){
        if($d.SubjectDomainName){"$($d.SubjectDomainName)\$($d.SubjectUserName)"} else {$d.SubjectUserName}
      } elseif($d.SubjectUserSid){ $d.SubjectUserSid } else { "" }

      $right = @($d.UserRight, $d.PrivilegeList) | Where-Object { $_ } | Select-Object -First 1

      $secOut += [pscustomobject]@{
        TimeCreated = $ev.TimeCreated
        Id          = $ev.Id
        Subject     = $subject
        Right       = $right
        ProcessName = $d.ProcessName
        CommandLine = $d.CommandLine
        FirstLine   = (($ev.Message -split "`n")[0]).Trim()
      }
    }
    if ($secOut.Count -gt 0) { $secOut | Export-Csv $secCsv -NoTypeInformation -Encoding UTF8 }
  } catch {
    W ""
    W "Security query failed or no auditing: $($_.Exception.Message)"
  }

  W ""
  if ($secOut.Count -gt 0) {
    W "Security hits: $($secOut.Count) (saved: $secCsv)"
    W "Most relevant (4704/4705 first):"
    $secOut | Sort-Object @{e={if($_.Id -in 4704,4705){0}else{1}}}, TimeCreated |
      Select-Object -First 10 TimeCreated,Id,Subject,Right,ProcessName,FirstLine |
      ForEach-Object { W (" - " + ($_ | ConvertTo-Json -Compress)) }
  } else {
    W "Security hits: 0 (4704/4705/4688 not found in window)"
  }

  $taskOut = @()
  try {
    $rawTask = Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TaskScheduler/Operational'; StartTime=$start; EndTime=$end} -ErrorAction Stop |
               Sort-Object TimeCreated
    foreach ($ev in $rawTask) {
      $x = [xml]$ev.ToXml()
      $d = @{}
      foreach($n in $x.Event.EventData.Data){ $d[$n.Name] = $n.'#text' }
      $taskOut += [pscustomobject]@{
        TimeCreated = $ev.TimeCreated
        Id          = $ev.Id
        TaskName    = $d.TaskName
        ResultCode  = $d.ResultCode
        FirstLine   = (($ev.Message -split "`n")[0]).Trim()
      }
    }
    if ($taskOut.Count -gt 0) { $taskOut | Export-Csv $taskCsv -NoTypeInformation -Encoding UTF8 }
  } catch {}

  W ""
  if ($taskOut.Count -gt 0) {
    W "TaskScheduler hits: $($taskOut.Count) (saved: $taskCsv)"
    $taskOut | Select-Object -First 12 TimeCreated,Id,TaskName,ResultCode,FirstLine |
      ForEach-Object { W (" - " + ($_ | ConvertTo-Json -Compress)) }
  } else {
    W "TaskScheduler hits: 0 (or Operational log disabled)"
  }

  $sysOut = @()
  try {
    $rawSys = Get-WinEvent -FilterHashtable @{LogName='System'; StartTime=$start; EndTime=$end} -ErrorAction Stop |
              Where-Object { $_.ProviderName -in 'Microsoft-Windows-GroupPolicy','SceCli','Service Control Manager' } |
              Sort-Object TimeCreated
    foreach($ev in $rawSys){
      $sysOut += [pscustomobject]@{
        TimeCreated = $ev.TimeCreated
        Id          = $ev.Id
        Provider    = $ev.ProviderName
        FirstLine   = (($ev.Message -split "`n")[0]).Trim()
      }
    }
    if ($sysOut.Count -gt 0) { $sysOut | Export-Csv $sysCsv -NoTypeInformation -Encoding UTF8 }
  } catch {}

  W ""
  if ($sysOut.Count -gt 0) {
    W "System hits (GroupPolicy/SceCli/SCM): $($sysOut.Count) (saved: $sysCsv)"
    $sysOut | Select-Object -First 12 TimeCreated,Provider,Id,FirstLine |
      ForEach-Object { W (" - " + ($_ | ConvertTo-Json -Compress)) }
  } else {
    W "System hits: 0 (GroupPolicy/SceCli/SCM not found in window)"
  }
}

W ""
W "=== Quick conclusion (heuristic) ==="
if ($batchLine) {
  if ($Account -and $acctSid -and $acctSid -ne "<cannot translate to SID>" -and $present -eq $false) {
    W "-> The provided account is NOT in SeBatchLogonRight (SID not found). That explains the failure."
  } else {
    W "-> SeBatchLogonRight is defined (whitelist). If the account disappears after '1 day + reboot', something is reapplying this list."
  }
} else {
  W "-> SeBatchLogonRight was not present in the export; it may be controlled by a different mechanism/scope."
}

if ($db) { W "-> Next correlation point is secedit.sdb LastWriteTime: $($db.LastWriteTime)" }

Write-Host "OK. Summary: $summary" -ForegroundColor Green
Write-Host "Files: $cfgPath ; $secCsv ; $taskCsv ; $sysCsv" -ForegroundColor Cyan

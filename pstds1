$TargetUserName = "" 
$LogDir = "z:\scripts\logs1"
$LogFile = "$LogDir\Monitor_LogonRights.txt"
$CheckIntervalSeconds = 15

if (!(Test-Path $LogDir)) { New-Item -ItemType Directory -Path $LogDir -Force | Out-Null }

$LsaCode = @"
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace LsaSecurity {
    public class Wrapper {
        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern uint LsaOpenPolicy(ref LSA_UNICODE_STRING SystemName, ref LSA_OBJECT_ATTRIBUTES ObjectAttributes, uint DesiredAccess, out IntPtr PolicyHandle);
        
        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern uint LsaEnumerateAccountRights(IntPtr PolicyHandle, byte[] AccountSid, out IntPtr UserRights, out ulong CountOfRights);
        
        [DllImport("advapi32.dll")] private static extern uint LsaClose(IntPtr ObjectHandle);
        [DllImport("advapi32.dll")] private static extern uint LsaFreeMemory(IntPtr Buffer);

        [StructLayout(LayoutKind.Sequential)] private struct LSA_UNICODE_STRING { public ushort Length; public ushort MaximumLength; public IntPtr Buffer; }
        [StructLayout(LayoutKind.Sequential)] private struct LSA_OBJECT_ATTRIBUTES { public int Length; public IntPtr RootDirectory; public IntPtr ObjectName; public uint Attributes; public IntPtr SecurityDescriptor; public IntPtr SecurityQualityOfService; }

        public static List<string> GetAccountRights(string sidString) {
            uint POLICY_LOOKUP_NAMES = 0x00000800; 
            IntPtr policyHandle = IntPtr.Zero;
            LSA_OBJECT_ATTRIBUTES objAttr = new LSA_OBJECT_ATTRIBUTES();
            LSA_UNICODE_STRING sysName = new LSA_UNICODE_STRING();
            List<string> rightsList = new List<string>();

            uint res = LsaOpenPolicy(ref sysName, ref objAttr, POLICY_LOOKUP_NAMES, out policyHandle);
            if (res != 0) return rightsList;

            try {
                SecurityIdentifier sid = new SecurityIdentifier(sidString);
                byte[] sidBytes = new byte[sid.BinaryLength];
                sid.GetBinaryForm(sidBytes, 0);

                IntPtr userRightsPtr = IntPtr.Zero;
                ulong countOfRights = 0;

                res = LsaEnumerateAccountRights(policyHandle, sidBytes, out userRightsPtr, out countOfRights);
                
                if (res == 0xC0000034) return rightsList; 
                if (res != 0) return rightsList;

                IntPtr currentPtr = userRightsPtr;
                for (ulong i = 0; i < countOfRights; i++) {
                    LSA_UNICODE_STRING lus = (LSA_UNICODE_STRING)Marshal.PtrToStructure(currentPtr, typeof(LSA_UNICODE_STRING));
                    string rightName = Marshal.PtrToStringUni(lus.Buffer, lus.Length / 2);
                    rightsList.Add(rightName);
                    currentPtr = (IntPtr)((long)currentPtr + Marshal.SizeOf(typeof(LSA_UNICODE_STRING)));
                }
                
                LsaFreeMemory(userRightsPtr);
            }
            catch { }
            finally { LsaClose(policyHandle); }
            return rightsList;
        }
    }
}
"@

if (-not ("LsaSecurity.Wrapper" -as [type])) { Add-Type -TypeDefinition $LsaCode }

Write-Host "Monitor started. Target: $TargetUserName" -ForegroundColor Cyan
Write-Host "Interval: $CheckIntervalSeconds seconds" -ForegroundColor Gray
Write-Host "Log file: $LogFile" -ForegroundColor Gray

$StartMsg = "--- MONITOR STARTED: $(Get-Date) ---"
$StartMsg | Out-File -FilePath $LogFile -Append -Encoding UTF8

$AlertTriggered = $false

while ($true) {
    
    $BatchFound = $false
    $ServiceFound = $false
    $CurrentRights = @()
    $SidString = ""
    $ErrorDetected = $false

    try {
        $objUser = New-Object System.Security.Principal.NTAccount($TargetUserName)
        $SidString = $objUser.Translate([System.Security.Principal.SecurityIdentifier]).Value
        
        $CurrentRights = [LsaSecurity.Wrapper]::GetAccountRights($SidString)

        if ($CurrentRights -contains "SeBatchLogonRight") { $BatchFound = $true }
        if ($CurrentRights -contains "SeServiceLogonRight") { $ServiceFound = $true }
    }
    catch {
        Write-Host "Error resolving SID." -ForegroundColor Yellow
    }

    if (-not $BatchFound -or -not $ServiceFound) {
        $ErrorDetected = $true
    }

    if ($ErrorDetected) {
        
        if (-not $AlertTriggered) {
            $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            
            $ErrorMsg = "[$Timestamp] ERROR: Rights missing."
            if (-not $BatchFound) { $ErrorMsg += " [SeBatchLogonRight]" }
            if (-not $ServiceFound) { $ErrorMsg += " [SeServiceLogonRight]" }

            Write-Host $ErrorMsg -ForegroundColor Red
            Write-Host "Exporting recent Security logs..." -ForegroundColor Red
            
            "==================================================" | Out-File -FilePath $LogFile -Append
            $ErrorMsg | Out-File -FilePath $LogFile -Append
            "SID: $SidString" | Out-File -FilePath $LogFile -Append
            "Rights: $($CurrentRights -join ', ')" | Out-File -FilePath $LogFile -Append
            
            "--- SECURITY LOGS (Last 3 Mins) ---" | Out-File -FilePath $LogFile -Append
            
            try {
                $Events = Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime=(Get-Date).AddMinutes(-3)} -ErrorAction Stop
                
                foreach ($Event in $Events) {
                    $ProcessName = $Event.Properties[6].Value
                    $SubjectUser = $Event.Properties[1].Value
                    
                    $LogLine = "TIME: $($Event.TimeCreated) | ID: $($Event.Id) | USER: $SubjectUser | PROCESS: $ProcessName"
                    $LogLine | Out-File -FilePath $LogFile -Append
                }
            }
            catch {
                "No events found." | Out-File -FilePath $LogFile -Append
            }
            "==================================================" | Out-File -FilePath $LogFile -Append
            
            $AlertTriggered = $true
        
        } else {
            Write-Host "Status: Error persisting." -ForegroundColor DarkRed
        }

    } else {
        if ($AlertTriggered) {
            $ResolveMsg = "[$(Get-Date -Format 'HH:mm:ss')] Status: RESOLVED. Monitoring resumed."
            Write-Host $ResolveMsg -ForegroundColor Green
            $ResolveMsg | Out-File -FilePath $LogFile -Append
            $AlertTriggered = $false 
        } else {
            Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Status: OK" -ForegroundColor Green
        }
    }
    
    Start-Sleep -Seconds $CheckIntervalSeconds
}
